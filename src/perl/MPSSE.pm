# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.4
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

package MPSSE;
use base qw(Exporter);
use base qw(DynaLoader);
package MPSSEc;
bootstrap MPSSE;
package MPSSE;
@EXPORT = qw();

# ---------- BASE METHODS -------------

package MPSSE;

sub TIEHASH {
    my ($classname,$obj) = @_;
    return bless $obj, $classname;
}

sub CLEAR { }

sub FIRSTKEY { }

sub NEXTKEY { }

sub FETCH {
    my ($self,$field) = @_;
    my $member_func = "swig_${field}_get";
    $self->$member_func();
}

sub STORE {
    my ($self,$field,$newval) = @_;
    my $member_func = "swig_${field}_set";
    $self->$member_func($newval);
}

sub this {
    my $ptr = shift;
    return tied(%$ptr);
}


# ------- FUNCTION WRAPPERS --------

package MPSSE;

*MPSSE = *MPSSEc::MPSSE;
*Open = *MPSSEc::Open;
*OpenIndex = *MPSSEc::OpenIndex;
*Close = *MPSSEc::Close;
*ErrorString = *MPSSEc::ErrorString;
*SetMode = *MPSSEc::SetMode;
*EnableBitmode = *MPSSEc::EnableBitmode;
*SetClock = *MPSSEc::SetClock;
*GetClock = *MPSSEc::GetClock;
*GetVid = *MPSSEc::GetVid;
*GetPid = *MPSSEc::GetPid;
*GetDescription = *MPSSEc::GetDescription;
*SetLoopback = *MPSSEc::SetLoopback;
*SetCSIdle = *MPSSEc::SetCSIdle;
*Start = *MPSSEc::Start;
*Write = *MPSSEc::Write;
*Stop = *MPSSEc::Stop;
*GetAck = *MPSSEc::GetAck;
*SetAck = *MPSSEc::SetAck;
*SendAcks = *MPSSEc::SendAcks;
*SendNacks = *MPSSEc::SendNacks;
*FlushAfterRead = *MPSSEc::FlushAfterRead;
*PinHigh = *MPSSEc::PinHigh;
*PinLow = *MPSSEc::PinLow;
*SetDirection = *MPSSEc::SetDirection;
*WriteBits = *MPSSEc::WriteBits;
*ReadBits = *MPSSEc::ReadBits;
*WritePins = *MPSSEc::WritePins;
*ReadPins = *MPSSEc::ReadPins;
*PinState = *MPSSEc::PinState;
*Tristate = *MPSSEc::Tristate;
*Version = *MPSSEc::Version;
*Read = *MPSSEc::Read;
*Transfer = *MPSSEc::Transfer;

############# Class : MPSSE::vid_pid ##############

package MPSSE::vid_pid;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( MPSSE );
%OWNER = ();
%ITERATORS = ();
*swig_vid_get = *MPSSEc::vid_pid_vid_get;
*swig_vid_set = *MPSSEc::vid_pid_vid_set;
*swig_pid_get = *MPSSEc::vid_pid_pid_get;
*swig_pid_set = *MPSSEc::vid_pid_pid_set;
*swig_description_get = *MPSSEc::vid_pid_description_get;
*swig_description_set = *MPSSEc::vid_pid_description_set;
sub new {
    my $pkg = shift;
    my $self = MPSSEc::new_vid_pid(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        MPSSEc::delete_vid_pid($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : MPSSE::mpsse_context ##############

package MPSSE::mpsse_context;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( MPSSE );
%OWNER = ();
%ITERATORS = ();
*swig_description_get = *MPSSEc::mpsse_context_description_get;
*swig_description_set = *MPSSEc::mpsse_context_description_set;
*swig_ftdi_get = *MPSSEc::mpsse_context_ftdi_get;
*swig_ftdi_set = *MPSSEc::mpsse_context_ftdi_set;
*swig_mode_get = *MPSSEc::mpsse_context_mode_get;
*swig_mode_set = *MPSSEc::mpsse_context_mode_set;
*swig_status_get = *MPSSEc::mpsse_context_status_get;
*swig_status_set = *MPSSEc::mpsse_context_status_set;
*swig_flush_after_read_get = *MPSSEc::mpsse_context_flush_after_read_get;
*swig_flush_after_read_set = *MPSSEc::mpsse_context_flush_after_read_set;
*swig_vid_get = *MPSSEc::mpsse_context_vid_get;
*swig_vid_set = *MPSSEc::mpsse_context_vid_set;
*swig_pid_get = *MPSSEc::mpsse_context_pid_get;
*swig_pid_set = *MPSSEc::mpsse_context_pid_set;
*swig_clock_get = *MPSSEc::mpsse_context_clock_get;
*swig_clock_set = *MPSSEc::mpsse_context_clock_set;
*swig_xsize_get = *MPSSEc::mpsse_context_xsize_get;
*swig_xsize_set = *MPSSEc::mpsse_context_xsize_set;
*swig_open_get = *MPSSEc::mpsse_context_open_get;
*swig_open_set = *MPSSEc::mpsse_context_open_set;
*swig_ftdi_initialized_get = *MPSSEc::mpsse_context_ftdi_initialized_get;
*swig_ftdi_initialized_set = *MPSSEc::mpsse_context_ftdi_initialized_set;
*swig_endianess_get = *MPSSEc::mpsse_context_endianess_get;
*swig_endianess_set = *MPSSEc::mpsse_context_endianess_set;
*swig_tris_get = *MPSSEc::mpsse_context_tris_get;
*swig_tris_set = *MPSSEc::mpsse_context_tris_set;
*swig_pstart_get = *MPSSEc::mpsse_context_pstart_get;
*swig_pstart_set = *MPSSEc::mpsse_context_pstart_set;
*swig_pstop_get = *MPSSEc::mpsse_context_pstop_get;
*swig_pstop_set = *MPSSEc::mpsse_context_pstop_set;
*swig_pidle_get = *MPSSEc::mpsse_context_pidle_get;
*swig_pidle_set = *MPSSEc::mpsse_context_pidle_set;
*swig_gpioh_get = *MPSSEc::mpsse_context_gpioh_get;
*swig_gpioh_set = *MPSSEc::mpsse_context_gpioh_set;
*swig_trish_get = *MPSSEc::mpsse_context_trish_get;
*swig_trish_set = *MPSSEc::mpsse_context_trish_set;
*swig_bitbang_get = *MPSSEc::mpsse_context_bitbang_get;
*swig_bitbang_set = *MPSSEc::mpsse_context_bitbang_set;
*swig_tx_get = *MPSSEc::mpsse_context_tx_get;
*swig_tx_set = *MPSSEc::mpsse_context_tx_set;
*swig_rx_get = *MPSSEc::mpsse_context_rx_get;
*swig_rx_set = *MPSSEc::mpsse_context_rx_set;
*swig_txrx_get = *MPSSEc::mpsse_context_txrx_get;
*swig_txrx_set = *MPSSEc::mpsse_context_txrx_set;
*swig_tack_get = *MPSSEc::mpsse_context_tack_get;
*swig_tack_set = *MPSSEc::mpsse_context_tack_set;
*swig_rack_get = *MPSSEc::mpsse_context_rack_get;
*swig_rack_set = *MPSSEc::mpsse_context_rack_set;
sub new {
    my $pkg = shift;
    my $self = MPSSEc::new_mpsse_context(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        MPSSEc::delete_mpsse_context($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : MPSSE::swig_string_data ##############

package MPSSE::swig_string_data;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( MPSSE );
%OWNER = ();
%ITERATORS = ();
*swig_size_get = *MPSSEc::swig_string_data_size_get;
*swig_size_set = *MPSSEc::swig_string_data_size_set;
*swig_data_get = *MPSSEc::swig_string_data_data_get;
*swig_data_set = *MPSSEc::swig_string_data_data_set;
sub new {
    my $pkg = shift;
    my $self = MPSSEc::new_swig_string_data(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        MPSSEc::delete_swig_string_data($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


# ------- VARIABLE STUBS --------

package MPSSE;

*MPSSE_OK = *MPSSEc::MPSSE_OK;
*MPSSE_FAIL = *MPSSEc::MPSSE_FAIL;
*MSB = *MPSSEc::MSB;
*LSB = *MPSSEc::LSB;
*CHUNK_SIZE = *MPSSEc::CHUNK_SIZE;
*SPI_RW_SIZE = *MPSSEc::SPI_RW_SIZE;
*SPI_TRANSFER_SIZE = *MPSSEc::SPI_TRANSFER_SIZE;
*I2C_TRANSFER_SIZE = *MPSSEc::I2C_TRANSFER_SIZE;
*LATENCY_MS = *MPSSEc::LATENCY_MS;
*TIMEOUT_DIVISOR = *MPSSEc::TIMEOUT_DIVISOR;
*USB_TIMEOUT = *MPSSEc::USB_TIMEOUT;
*SETUP_DELAY = *MPSSEc::SETUP_DELAY;
*BITMODE_RESET = *MPSSEc::BITMODE_RESET;
*BITMODE_MPSSE = *MPSSEc::BITMODE_MPSSE;
*CMD_SIZE = *MPSSEc::CMD_SIZE;
*MAX_SETUP_COMMANDS = *MPSSEc::MAX_SETUP_COMMANDS;
*SS_TX_COUNT = *MPSSEc::SS_TX_COUNT;
*LOW = *MPSSEc::LOW;
*HIGH = *MPSSEc::HIGH;
*NUM_GPIOL_PINS = *MPSSEc::NUM_GPIOL_PINS;
*NUM_GPIO_PINS = *MPSSEc::NUM_GPIO_PINS;
*NULL_CONTEXT_ERROR_MSG = *MPSSEc::NULL_CONTEXT_ERROR_MSG;
*IFACE_ANY = *MPSSEc::IFACE_ANY;
*IFACE_A = *MPSSEc::IFACE_A;
*IFACE_B = *MPSSEc::IFACE_B;
*IFACE_C = *MPSSEc::IFACE_C;
*IFACE_D = *MPSSEc::IFACE_D;
*ONE_HUNDRED_KHZ = *MPSSEc::ONE_HUNDRED_KHZ;
*FOUR_HUNDRED_KHZ = *MPSSEc::FOUR_HUNDRED_KHZ;
*ONE_MHZ = *MPSSEc::ONE_MHZ;
*TWO_MHZ = *MPSSEc::TWO_MHZ;
*FIVE_MHZ = *MPSSEc::FIVE_MHZ;
*SIX_MHZ = *MPSSEc::SIX_MHZ;
*TEN_MHZ = *MPSSEc::TEN_MHZ;
*TWELVE_MHZ = *MPSSEc::TWELVE_MHZ;
*FIFTEEN_MHZ = *MPSSEc::FIFTEEN_MHZ;
*THIRTY_MHZ = *MPSSEc::THIRTY_MHZ;
*SIXTY_MHZ = *MPSSEc::SIXTY_MHZ;
*SPI0 = *MPSSEc::SPI0;
*SPI1 = *MPSSEc::SPI1;
*SPI2 = *MPSSEc::SPI2;
*SPI3 = *MPSSEc::SPI3;
*I2C = *MPSSEc::I2C;
*GPIO = *MPSSEc::GPIO;
*BITBANG = *MPSSEc::BITBANG;
*SK = *MPSSEc::SK;
*DO = *MPSSEc::DO;
*DI = *MPSSEc::DI;
*CS = *MPSSEc::CS;
*GPIO0 = *MPSSEc::GPIO0;
*GPIO1 = *MPSSEc::GPIO1;
*GPIO2 = *MPSSEc::GPIO2;
*GPIO3 = *MPSSEc::GPIO3;
*GPIOL0 = *MPSSEc::GPIOL0;
*GPIOL1 = *MPSSEc::GPIOL1;
*GPIOL2 = *MPSSEc::GPIOL2;
*GPIOL3 = *MPSSEc::GPIOL3;
*GPIOH0 = *MPSSEc::GPIOH0;
*GPIOH1 = *MPSSEc::GPIOH1;
*GPIOH2 = *MPSSEc::GPIOH2;
*GPIOH3 = *MPSSEc::GPIOH3;
*GPIOH4 = *MPSSEc::GPIOH4;
*GPIOH5 = *MPSSEc::GPIOH5;
*GPIOH6 = *MPSSEc::GPIOH6;
*GPIOH7 = *MPSSEc::GPIOH7;
*ACK = *MPSSEc::ACK;
*NACK = *MPSSEc::NACK;
*INVALID_COMMAND = *MPSSEc::INVALID_COMMAND;
*ENABLE_ADAPTIVE_CLOCK = *MPSSEc::ENABLE_ADAPTIVE_CLOCK;
*DISABLE_ADAPTIVE_CLOCK = *MPSSEc::DISABLE_ADAPTIVE_CLOCK;
*ENABLE_3_PHASE_CLOCK = *MPSSEc::ENABLE_3_PHASE_CLOCK;
*DISABLE_3_PHASE_CLOCK = *MPSSEc::DISABLE_3_PHASE_CLOCK;
*TCK_X5 = *MPSSEc::TCK_X5;
*TCK_D5 = *MPSSEc::TCK_D5;
*CLOCK_N_CYCLES = *MPSSEc::CLOCK_N_CYCLES;
*CLOCK_N8_CYCLES = *MPSSEc::CLOCK_N8_CYCLES;
*PULSE_CLOCK_IO_HIGH = *MPSSEc::PULSE_CLOCK_IO_HIGH;
*PULSE_CLOCK_IO_LOW = *MPSSEc::PULSE_CLOCK_IO_LOW;
*CLOCK_N8_CYCLES_IO_HIGH = *MPSSEc::CLOCK_N8_CYCLES_IO_HIGH;
*CLOCK_N8_CYCLES_IO_LOW = *MPSSEc::CLOCK_N8_CYCLES_IO_LOW;
*TRISTATE_IO = *MPSSEc::TRISTATE_IO;
*STARTED = *MPSSEc::STARTED;
*STOPPED = *MPSSEc::STOPPED;
1;
